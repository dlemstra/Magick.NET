// Copyright 2013-2019 Dirk Lemstra <https://github.com/dlemstra/Magick.NET/>
//
// Licensed under the ImageMagick License (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
//
//   https://www.imagemagick.org/script/license.php
//
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.
// <auto-generated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Text;
using System.Xml;

#if Q8
using QuantumType = System.Byte;
#elif Q16
using QuantumType = System.UInt16;
#elif Q16HDRI
using QuantumType = System.Single;
#else
#error Not implemented!
#endif

namespace ImageMagick
{
    public sealed partial class MagickScript
    {
        private void ExecuteMagickSettings(XmlElement element, MagickSettings settings)
        {
            switch(element.Name[0])
            {
                case 'b':
                {
                    switch(element.Name[1])
                    {
                        case 'a':
                        {
                            ExecuteBackgroundColor(element, settings);
                            return;
                        }
                        case 'o':
                        {
                            ExecuteBorderColor(element, settings);
                            return;
                        }
                    }
                    break;
                }
                case 'c':
                {
                    switch(element.Name[2])
                    {
                        case 'l':
                        {
                            switch(element.Name[5])
                            {
                                case 'S':
                                {
                                    ExecuteColorSpace(element, settings);
                                    return;
                                }
                                case 'T':
                                {
                                    ExecuteColorType(element, settings);
                                    return;
                                }
                            }
                            break;
                        }
                        case 'm':
                        {
                            ExecuteCompression(element, settings);
                            return;
                        }
                    }
                    break;
                }
                case 'd':
                {
                    switch(element.Name[2])
                    {
                        case 'b':
                        {
                            ExecuteDebug(element, settings);
                            return;
                        }
                        case 'n':
                        {
                            ExecuteDensity(element, settings);
                            return;
                        }
                    }
                    break;
                }
                case 'e':
                {
                    ExecuteEndian(element, settings);
                    return;
                }
                case 'f':
                {
                    switch(element.Name[1])
                    {
                        case 'i':
                        {
                            switch(element.Name[4])
                            {
                                case 'C':
                                {
                                    ExecuteFillColor(element, settings);
                                    return;
                                }
                                case 'P':
                                {
                                    ExecuteFillPattern(element, settings);
                                    return;
                                }
                                case 'R':
                                {
                                    ExecuteFillRule(element, settings);
                                    return;
                                }
                            }
                            break;
                        }
                        case 'o':
                        {
                            switch(element.Name[2])
                            {
                                case 'n':
                                {
                                    if (element.Name.Length == 4)
                                    {
                                        ExecuteFont(element, settings);
                                        return;
                                    }
                                    switch(element.Name[4])
                                    {
                                        case 'F':
                                        {
                                            ExecuteFontFamily(element, settings);
                                            return;
                                        }
                                        case 'P':
                                        {
                                            ExecuteFontPointsize(element, settings);
                                            return;
                                        }
                                        case 'S':
                                        {
                                            ExecuteFontStyle(element, settings);
                                            return;
                                        }
                                        case 'W':
                                        {
                                            ExecuteFontWeight(element, settings);
                                            return;
                                        }
                                    }
                                    break;
                                }
                                case 'r':
                                {
                                    ExecuteFormat(element, settings);
                                    return;
                                }
                            }
                            break;
                        }
                    }
                    break;
                }
                case 'p':
                {
                    ExecutePage(element, settings);
                    return;
                }
                case 's':
                {
                    switch(element.Name[1])
                    {
                        case 't':
                        {
                            switch(element.Name[6])
                            {
                                case 'A':
                                {
                                    ExecuteStrokeAntiAlias(element, settings);
                                    return;
                                }
                                case 'C':
                                {
                                    ExecuteStrokeColor(element, settings);
                                    return;
                                }
                                case 'D':
                                {
                                    switch(element.Name[10])
                                    {
                                        case 'A':
                                        {
                                            ExecuteStrokeDashArray(element, settings);
                                            return;
                                        }
                                        case 'O':
                                        {
                                            ExecuteStrokeDashOffset(element, settings);
                                            return;
                                        }
                                    }
                                    break;
                                }
                                case 'L':
                                {
                                    switch(element.Name[10])
                                    {
                                        case 'C':
                                        {
                                            ExecuteStrokeLineCap(element, settings);
                                            return;
                                        }
                                        case 'J':
                                        {
                                            ExecuteStrokeLineJoin(element, settings);
                                            return;
                                        }
                                    }
                                    break;
                                }
                                case 'M':
                                {
                                    ExecuteStrokeMiterLimit(element, settings);
                                    return;
                                }
                                case 'P':
                                {
                                    ExecuteStrokePattern(element, settings);
                                    return;
                                }
                                case 'W':
                                {
                                    ExecuteStrokeWidth(element, settings);
                                    return;
                                }
                            }
                            break;
                        }
                        case 'e':
                        {
                            if (element.Name.Length == 9)
                            {
                                ExecuteSetDefine(element, settings);
                                return;
                            }
                            if (element.Name.Length == 10)
                            {
                                ExecuteSetDefines(element, settings);
                                return;
                            }
                            break;
                        }
                    }
                    break;
                }
                case 't':
                {
                    switch(element.Name[4])
                    {
                        case 'A':
                        {
                            ExecuteTextAntiAlias(element, settings);
                            return;
                        }
                        case 'D':
                        {
                            ExecuteTextDirection(element, settings);
                            return;
                        }
                        case 'E':
                        {
                            ExecuteTextEncoding(element, settings);
                            return;
                        }
                        case 'G':
                        {
                            ExecuteTextGravity(element, settings);
                            return;
                        }
                        case 'I':
                        {
                            switch(element.Name[9])
                            {
                                case 'l':
                                {
                                    ExecuteTextInterlineSpacing(element, settings);
                                    return;
                                }
                                case 'w':
                                {
                                    ExecuteTextInterwordSpacing(element, settings);
                                    return;
                                }
                            }
                            break;
                        }
                        case 'K':
                        {
                            ExecuteTextKerning(element, settings);
                            return;
                        }
                        case 'U':
                        {
                            ExecuteTextUnderColor(element, settings);
                            return;
                        }
                    }
                    break;
                }
                case 'v':
                {
                    ExecuteVerbose(element, settings);
                    return;
                }
                case 'r':
                {
                    ExecuteRemoveDefine(element, settings);
                    return;
                }
            }
            throw new NotSupportedException(element.Name);
        }
        private void ExecuteBackgroundColor(XmlElement element, MagickSettings settings)
        {
            settings.BackgroundColor = GetValue<MagickColor>(element, "value");
        }
        private void ExecuteBorderColor(XmlElement element, MagickSettings settings)
        {
            settings.BorderColor = GetValue<MagickColor>(element, "value");
        }
        private void ExecuteColorSpace(XmlElement element, MagickSettings settings)
        {
            settings.ColorSpace = GetValue<ColorSpace>(element, "value");
        }
        private void ExecuteColorType(XmlElement element, MagickSettings settings)
        {
            settings.ColorType = GetValue<ColorType>(element, "value");
        }
        private void ExecuteCompression(XmlElement element, MagickSettings settings)
        {
            settings.Compression = GetValue<CompressionMethod>(element, "value");
        }
        private void ExecuteDebug(XmlElement element, MagickSettings settings)
        {
            settings.Debug = GetValue<Boolean>(element, "value");
        }
        private void ExecuteDensity(XmlElement element, MagickSettings settings)
        {
            settings.Density = GetValue<Density>(element, "value");
        }
        private void ExecuteEndian(XmlElement element, MagickSettings settings)
        {
            settings.Endian = GetValue<Endian>(element, "value");
        }
        private void ExecuteFillColor(XmlElement element, MagickSettings settings)
        {
            settings.FillColor = GetValue<MagickColor>(element, "value");
        }
        private void ExecuteFillPattern(XmlElement element, MagickSettings settings)
        {
            settings.FillPattern = CreateMagickImage(element);
        }
        private void ExecuteFillRule(XmlElement element, MagickSettings settings)
        {
            settings.FillRule = GetValue<FillRule>(element, "value");
        }
        private void ExecuteFont(XmlElement element, MagickSettings settings)
        {
            settings.Font = GetValue<String>(element, "value");
        }
        private void ExecuteFontFamily(XmlElement element, MagickSettings settings)
        {
            settings.FontFamily = GetValue<String>(element, "value");
        }
        private void ExecuteFontPointsize(XmlElement element, MagickSettings settings)
        {
            settings.FontPointsize = GetValue<double>(element, "value");
        }
        private void ExecuteFontStyle(XmlElement element, MagickSettings settings)
        {
            settings.FontStyle = GetValue<FontStyleType>(element, "value");
        }
        private void ExecuteFontWeight(XmlElement element, MagickSettings settings)
        {
            settings.FontWeight = GetValue<FontWeight>(element, "value");
        }
        private void ExecuteFormat(XmlElement element, MagickSettings settings)
        {
            settings.Format = GetValue<MagickFormat>(element, "value");
        }
        private void ExecutePage(XmlElement element, MagickSettings settings)
        {
            settings.Page = GetValue<MagickGeometry>(element, "value");
        }
        private void ExecuteStrokeAntiAlias(XmlElement element, MagickSettings settings)
        {
            settings.StrokeAntiAlias = GetValue<Boolean>(element, "value");
        }
        private void ExecuteStrokeColor(XmlElement element, MagickSettings settings)
        {
            settings.StrokeColor = GetValue<MagickColor>(element, "value");
        }
        private void ExecuteStrokeDashArray(XmlElement element, MagickSettings settings)
        {
            settings.StrokeDashArray = GetDoubleArray(element);
        }
        private void ExecuteStrokeDashOffset(XmlElement element, MagickSettings settings)
        {
            settings.StrokeDashOffset = GetValue<double>(element, "value");
        }
        private void ExecuteStrokeLineCap(XmlElement element, MagickSettings settings)
        {
            settings.StrokeLineCap = GetValue<LineCap>(element, "value");
        }
        private void ExecuteStrokeLineJoin(XmlElement element, MagickSettings settings)
        {
            settings.StrokeLineJoin = GetValue<LineJoin>(element, "value");
        }
        private void ExecuteStrokeMiterLimit(XmlElement element, MagickSettings settings)
        {
            settings.StrokeMiterLimit = GetValue<Int32>(element, "value");
        }
        private void ExecuteStrokePattern(XmlElement element, MagickSettings settings)
        {
            settings.StrokePattern = CreateMagickImage(element);
        }
        private void ExecuteStrokeWidth(XmlElement element, MagickSettings settings)
        {
            settings.StrokeWidth = GetValue<double>(element, "value");
        }
        private void ExecuteTextAntiAlias(XmlElement element, MagickSettings settings)
        {
            settings.TextAntiAlias = GetValue<Boolean>(element, "value");
        }
        private void ExecuteTextDirection(XmlElement element, MagickSettings settings)
        {
            settings.TextDirection = GetValue<TextDirection>(element, "value");
        }
        private void ExecuteTextEncoding(XmlElement element, MagickSettings settings)
        {
            settings.TextEncoding = GetValue<Encoding>(element, "value");
        }
        private void ExecuteTextGravity(XmlElement element, MagickSettings settings)
        {
            settings.TextGravity = GetValue<Gravity>(element, "value");
        }
        private void ExecuteTextInterlineSpacing(XmlElement element, MagickSettings settings)
        {
            settings.TextInterlineSpacing = GetValue<double>(element, "value");
        }
        private void ExecuteTextInterwordSpacing(XmlElement element, MagickSettings settings)
        {
            settings.TextInterwordSpacing = GetValue<double>(element, "value");
        }
        private void ExecuteTextKerning(XmlElement element, MagickSettings settings)
        {
            settings.TextKerning = GetValue<double>(element, "value");
        }
        private void ExecuteTextUnderColor(XmlElement element, MagickSettings settings)
        {
            settings.TextUnderColor = GetValue<MagickColor>(element, "value");
        }
        private void ExecuteVerbose(XmlElement element, MagickSettings settings)
        {
            settings.Verbose = GetValue<Boolean>(element, "value");
        }
        private void ExecuteRemoveDefine(XmlElement element, MagickSettings settings)
        {
            Hashtable arguments = new Hashtable();
            foreach (XmlAttribute attribute in element.Attributes)
            {
                if (attribute.Name == "format")
                    arguments["format"] = GetValue<MagickFormat>(attribute);
                else if (attribute.Name == "name")
                    arguments["name"] = GetValue<String>(attribute);
            }
            if (OnlyContains(arguments, "format", "name"))
                settings.RemoveDefine((MagickFormat)arguments["format"], (String)arguments["name"]);
            else if (OnlyContains(arguments, "name"))
                settings.RemoveDefine((String)arguments["name"]);
            else
                throw new ArgumentException("Invalid argument combination for 'removeDefine', allowed combinations are: [format, name] [name]");
        }
        private void ExecuteSetDefine(XmlElement element, MagickSettings settings)
        {
            Hashtable arguments = new Hashtable();
            foreach (XmlAttribute attribute in element.Attributes)
            {
                if (attribute.Name == "flag")
                    arguments["flag"] = GetValue<Boolean>(attribute);
                else if (attribute.Name == "format")
                    arguments["format"] = GetValue<MagickFormat>(attribute);
                else if (attribute.Name == "name")
                    arguments["name"] = GetValue<String>(attribute);
                else if (attribute.Name == "value")
                    arguments["value"] = GetValue<String>(attribute);
            }
            if (OnlyContains(arguments, "format", "name", "flag"))
                settings.SetDefine((MagickFormat)arguments["format"], (String)arguments["name"], (Boolean)arguments["flag"]);
            else if (OnlyContains(arguments, "format", "name", "value"))
                settings.SetDefine((MagickFormat)arguments["format"], (String)arguments["name"], (String)arguments["value"]);
            else if (OnlyContains(arguments, "name", "value"))
                settings.SetDefine((String)arguments["name"], (String)arguments["value"]);
            else
                throw new ArgumentException("Invalid argument combination for 'setDefine', allowed combinations are: [format, name, flag] [format, name, value] [name, value]");
        }
        private void ExecuteSetDefines(XmlElement element, MagickSettings settings)
        {
            IDefines defines_ = CreateIDefines(element["defines"]);
            settings.SetDefines(defines_);
        }
    }
}
